<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>ì»¤ë®¤ë‹ˆì¼€ì´ì…˜ë¶ìŠ¤ ì§€ì‹ì—°ê²°ì§€ë„</title>
  <style>
    html, body { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #f5f0e6; }
    #graph-container { width: 100%; height: 100%; }
    .node-tooltip {
      position: absolute;
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 5px;
      border-radius: 3px;
      pointer-events: none; /* crucial for mouse events to pass through to the canvas */
      font-family: sans-serif;
      font-size: 12px;
    }
    .scene-nav-info {
      display: none !important;
    }

    #zoom-controls {
    position: absolute;
    bottom: 20px; /* âœ… ìƒë‹¨ ëŒ€ì‹  í•˜ë‹¨ì— ë°°ì¹˜ */
    right: 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 6px;
    z-index: 10;
  }


    #zoom-controls button {
    font-size: 15px;
    padding: 10px 14px;
    background-color: #ffffffcc;
    border: 1px solid #aaa;
    border-radius: 6px;
    cursor: pointer;
    box-shadow: 1px 1px 4px rgba(0,0,0,0.2);
    touch-action: manipulation; /* âœ… ëª¨ë°”ì¼ í„°ì¹˜ ê°œì„  */
  }

  #zoom-slider {
    writing-mode: bt-lr;
    -webkit-appearance: slider-vertical;
    width: 30px;
    height: 150px;
    margin: 6px auto;
    background: transparent;
    touch-action: none; /* âœ… ëª¨ë°”ì¼ì—ì„œ ì˜ë„ì¹˜ ì•Šì€ ìŠ¤í¬ë¡¤ ë°©ì§€ */
  }

@media (max-width: 768px) {
  #zoom-slider {
    width: 20px;
    height: 100px;
  }
}


  </style>
</head>
<body>
  <div id="graph-container"></div>
  <div id="node-tooltip" class="node-tooltip" style="display: none;"></div>
  <div id="zoom-controls">
    <button id="zoom-in">ï¼‹</button>
    <input type="range" id="zoom-slider" min="50" max="1500" step=""60" value="250">
    <button id="zoom-out">ï¼</button>
  </div>
  

  <script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/3d-force-graph@1.71.3/dist/3d-force-graph.min.js"></script>
  <script src="https://d3js.org/d3.v7.min.js"></script> 

  <script>



    const pastelColors = [
      "#FFCDD2", "#F8BBD0", "#E1BEE7", "#D1C4E9",
      "#C5CAE9", "#BBDEFB", "#B3E5FC", "#B2EBF2",
      "#B2DFDB", "#C8E6C9", "#DCEDC8", "#F0F4C3",
      "#FFF9C4", "#FFECB3", "#FFE0B2", "#FFCCBC",
      "#D7CCC8", "#CFD8DC", "#F5E0DC", "#E0E0E0"
    ];

    const FONT_SIZE = 11;
    const PADDING_X = 10;
    const PADDING_Y = 5;
    const BORDER_RADIUS = 16;
    const HOVER_SCALE_FACTOR = 1; // í™•ëŒ€ íš¨ê³¼ëŠ” ë‹¤ì‹œ ì ìš©ë©ë‹ˆë‹¤. (ì›ë˜ ì½”ë“œë¡œ íšŒê·€)
    const NODE_BASE_SCALE = 15;

    const tooltipElement = document.getElementById('node-tooltip');

    // Cache for node textures
    const textureCache = new Map();
    const TEXTURE_RESOLUTION_SCALE = 2; // í•´ìƒë„ ë°°ìœ¨ì„ 2ë¡œ ë‚®ì¶°ì„œ ì„±ëŠ¥ ë¶€ë‹´ì„ ì¤„ì´ê³  í…ŒìŠ¤íŠ¸í•´ ë³´ì„¸ìš”.

    // drawRoundedRectì™€ drawRoundedRectInternalì€ ì›ë³¸ ì½”ë“œë¥¼ ìœ ì§€í•©ë‹ˆë‹¤.
    function drawRoundedRect(ctx, x, y, w, h, r, isHovered) {
        if (w < 2 * r) r = w / 2;
        if (h < 2 * r) r = h / 2;
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.arcTo(x + w, y, x + w, y + h, r);
        ctx.arcTo(x + w, y + h, x, y + h, r);
        ctx.arcTo(x, y + h, x, y, r);
        ctx.arcTo(x, y, x + w, y, r);
        ctx.closePath();

        if (isHovered) {
            ctx.shadowColor = "rgba(0,0,0,0.3)";
            ctx.shadowBlur = 8;
            ctx.shadowOffsetX = 3;
            ctx.shadowOffsetY = 3;
        } else {
            ctx.shadowColor = "rgba(0,0,0,0.15)";
            ctx.shadowBlur = 5;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;
        }
        ctx.fill();
        ctx.shadowColor = "transparent"; // Reset shadow for text
    }
    
    function drawRoundedRectInternal(ctx, x, y, w, h, r) {
        if (w < 2 * r) r = w / 2;
        if (h < 2 * r) r = h / 2;
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.arcTo(x + w, y, x + w, y + h, r);
        ctx.arcTo(x + w, y + h, x, y + h, r);
        ctx.arcTo(x, y + h, x, y, r);
        ctx.arcTo(x, y, x + w, y, r);
        ctx.closePath();
        ctx.fill();
    }


    function getNodeTexture(node, colorStr, isHovered = false) {
        const cacheKey = `${node.id}-${colorStr}-${isHovered}-${TEXTURE_RESOLUTION_SCALE}`;
        if (textureCache.has(cacheKey)) {
            return textureCache.get(cacheKey);
        }

        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        let currentFontSize = FONT_SIZE * TEXTURE_RESOLUTION_SCALE;
        let currentPaddingX = PADDING_X * TEXTURE_RESOLUTION_SCALE;
        let currentPaddingY = PADDING_Y * TEXTURE_RESOLUTION_SCALE;
        let currentBorderRadius = BORDER_RADIUS * TEXTURE_RESOLUTION_SCALE;

        let text = node.id;

        ctx.font = `${currentFontSize}px sans-serif`;
        const textMetrics = ctx.measureText(text);
        
        let nodeContentWidth = textMetrics.width + currentPaddingX * 2;
        let nodeContentHeight = currentFontSize + currentPaddingY * 2;

        const hoverScaleEffect = isHovered ? HOVER_SCALE_FACTOR : 1;
        const shadowBlurEffect = 5 * TEXTURE_RESOLUTION_SCALE;
        const shadowOffsetEffect = 2 * TEXTURE_RESOLUTION_SCALE;

        const extraPaddingForShadow = Math.max(shadowBlurEffect + Math.abs(shadowOffsetEffect), 5 * TEXTURE_RESOLUTION_SCALE);


        canvas.width = nodeContentWidth + extraPaddingForShadow * 2;
        canvas.height = nodeContentHeight + extraPaddingForShadow * 2;
        
        const drawX = extraPaddingForShadow;
        const drawY = extraPaddingForShadow;

              // ğŸ¯ ê·¸ë¦¼ì íš¨ê³¼ ê³ ì •
        ctx.shadowColor = "rgba(0,0,0,0.15)";
        ctx.shadowBlur = 5 * TEXTURE_RESOLUTION_SCALE;
        ctx.shadowOffsetX = 2 * TEXTURE_RESOLUTION_SCALE;
        ctx.shadowOffsetY = 2 * TEXTURE_RESOLUTION_SCALE;

        function getDarkerColor(hex, factor = 1.05) {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        const darker = (c) => Math.max(0, Math.min(255, Math.floor(c * factor)));
        return `rgb(${darker(r)}, ${darker(g)}, ${darker(b)})`;
      }


        const bgColor = isHovered ? getDarkerColor(colorStr) : colorStr;
        ctx.fillStyle = bgColor;
        drawRoundedRectInternal(ctx, drawX, drawY, nodeContentWidth, nodeContentHeight, currentBorderRadius);


        ctx.shadowColor = "transparent";

        ctx.fillStyle = isHovered ? '#000000' : '#333';
        ctx.font = `${currentFontSize}px sans-serif`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(text, drawX + nodeContentWidth / 2, drawY + nodeContentHeight / 2);
        
        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        textureCache.set(cacheKey, texture);
        return texture;
    }


    fetch("tags_3d_A.json")
      .then(res => res.json())
      .then(data => {
        // â˜…â˜…â˜… ë…¸ë“œ ê°„ ê±°ë¦¬ ì¡°ì ˆì„ ìœ„í•œ ë³€ê²½ ì‚¬í•­ â˜…â˜…â˜…
        const INITIAL_COORDINATE_SCALE_FACTOR = 100; // ì´ˆê¸° ì¢Œí‘œ ìŠ¤ì¼€ì¼ë§ íŒ©í„° (ì—¬ì „íˆ ì „ë°˜ì ì¸ ë¶„í¬ì— ì˜í–¥)

        const nodes = data.map(d => ({
          id: d.id,
          name: d.id,
          group: d.group,
          // â˜…â˜…â˜… fx, fy, fz ëŒ€ì‹  x, y, zë¡œ ì´ˆê¸° ìœ„ì¹˜ë§Œ ì§€ì • â˜…â˜…â˜…
          x: d.x * INITIAL_COORDINATE_SCALE_FACTOR, // D3 Forceê°€ ì´ ì´ˆê¸°ê°’ì„ ê¸°ì¤€ìœ¼ë¡œ ì‹œë®¬ë ˆì´ì…˜ ì‹œì‘
          y: d.y * INITIAL_COORDINATE_SCALE_FACTOR,
          z: d.z * INITIAL_COORDINATE_SCALE_FACTOR,
          url: `http://commbooks.com/ë„ì„œ-íƒœê·¸/${encodeURIComponent(d.id.replace(/\s+/g, '-'))}`,
          val: 0.5
        }));

        const graphData = { nodes, links: [] };
        let hoveredNode = null;

        const isMobile = /Mobi|Android/i.test(navigator.userAgent);
        // í„°ì¹˜ ìƒíƒœ ì¶”ì  ë³€ìˆ˜
          let isTouchZooming = false;
          let touchStartTime = 0;
          let lastTouchCount = 0;

          // í„°ì¹˜ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€
          document.addEventListener('touchstart', (e) => {
            touchStartTime = Date.now();
            lastTouchCount = e.touches.length;
            if (e.touches.length > 1) {
              isTouchZooming = true;
            }
          }, { passive: true });

          document.addEventListener('touchend', (e) => {
            const touchDuration = Date.now() - touchStartTime;
            
            // ë©€í‹°í„°ì¹˜ì˜€ê±°ë‚˜, ë„ˆë¬´ ê¸´ í„°ì¹˜ì¸ ê²½ìš°ë§Œ ì¤Œìœ¼ë¡œ ê°„ì£¼
            if (lastTouchCount > 1 || touchDuration > 1000) {
              // ì¤Œ ìƒíƒœë¥¼ ì ì‹œ ìœ ì§€í•˜ì—¬ ì˜ë„ì¹˜ ì•Šì€ í´ë¦­ ë°©ì§€
              setTimeout(() => {
                isTouchZooming = false;
              }, 200);
            } else {
              isTouchZooming = false;
            }
          }, { passive: true });

          document.addEventListener('touchmove', (e) => {
            if (e.touches.length > 1) {
              isTouchZooming = true;
            }
          }, { passive: true });

        const Graph = ForceGraph3D()
          (document.getElementById('graph-container'))
          .graphData(graphData)
          .nodeLabel(null)
          .nodeColor(node => pastelColors[node.group % pastelColors.length])
          .backgroundColor('#f5f0e6')
          .enableNodeDrag(false) // ë“œë˜ê·¸ëŠ” ì—¬ì „íˆ ë¹„í™œì„±í™”
          .nodeThreeObject(node => {
            const colorStr = pastelColors[node.group % pastelColors.length];
            const isHovered = hoveredNode === node; // í˜¸ë²„ ìƒíƒœì— ë”°ë¼ í…ìŠ¤ì²˜ ìƒì„±
            
            const material = new THREE.SpriteMaterial({
                map: getNodeTexture(node, colorStr, isHovered),
                transparent: true,
                depthWrite: false,
            });
            const sprite = new THREE.Sprite(material);

            const canvasForTexture = getNodeTexture(node, colorStr, isHovered).image;
            const spriteWidth = canvasForTexture.width;
            const spriteHeight = canvasForTexture.height;
            
            // â˜…â˜…â˜… ì›ë³¸ ì½”ë“œì˜ í˜¸ë²„ ìŠ¤ì¼€ì¼ë§ ë¡œì§ ìœ ì§€ â˜…â˜…â˜…
            let scale = NODE_BASE_SCALE * (isHovered ? HOVER_SCALE_FACTOR : 1);
            sprite.scale.set(spriteWidth * scale / 100, spriteHeight * scale / 100, 1);

            sprite.userData = { node, baseScaleX: sprite.scale.x, baseScaleY: sprite.scale.y };
            return sprite;
          })
          .onNodeHover(node => {
            const GFG = Graph;
            const container = document.getElementById('graph-container');
            if (hoveredNode === node && node !== null) return;
            
            // Update hovered node texture and scale (original behavior)
            if (hoveredNode) { // De-highlight previous
                const prevSprite = hoveredNode.__threeObj;
                if (prevSprite) {
                    const colorStr = pastelColors[hoveredNode.group % pastelColors.length];
                    if (prevSprite.material.map) prevSprite.material.map.dispose(); // ë©”ëª¨ë¦¬ í•´ì œ
                    prevSprite.material.map = getNodeTexture(hoveredNode, colorStr, false);
                    prevSprite.scale.set(prevSprite.userData.baseScaleX, prevSprite.userData.baseScaleY, 1);
                }
            }
            
            hoveredNode = node;

            if (node) {
                const currentSprite = node.__threeObj;
                if (currentSprite) {
                    const colorStr = pastelColors[node.group % pastelColors.length];
                    if (currentSprite.material.map) currentSprite.material.map.dispose(); // ë©”ëª¨ë¦¬ í•´ì œ
                    currentSprite.material.map = getNodeTexture(node, colorStr, true);
                    currentSprite.scale.set(
                        currentSprite.userData.baseScaleX * HOVER_SCALE_FACTOR, 
                        currentSprite.userData.baseScaleY * HOVER_SCALE_FACTOR, 
                        1
                    );
                }
                container.style.cursor = 'pointer';
                
                if (!isMobile) {
                  tooltipElement.style.display = 'block';
                  tooltipElement.innerHTML = node.name;
                } else {
                  tooltipElement.style.display = 'none';
                }

            } else {
                container.style.cursor = 'grab';
                tooltipElement.style.display = 'none';
            }
            GFG.renderer().domElement.addEventListener('mousemove', onMouseMoveTooltip, false);
          })
          .onNodeClick(node => {
  // ëª¨ë°”ì¼ í„°ì¹˜ ìƒíƒœ ì¶”ì 
            if (isTouchZooming) {
              return; // ì¤Œ ì¤‘ì¼ ë•ŒëŠ” í´ë¦­ ë¬´ì‹œ
            }
            
            if (node.url) {
              window.open(node.url, '_blank');
            }
          })

          // â˜…â˜…â˜… D3 Force ì‹œë®¬ë ˆì´ì…˜ ì„¤ì • ì¶”ê°€ â˜…â˜…â˜…
          // ê¸°ë³¸ ì²™ë ¥ (charge) í˜ ì„¤ì •
          .d3Force('charge', d3.forceManyBody()
            .strength(-2) // ë…¸ë“œë“¤ì„ ì„œë¡œ ë°€ì–´ë‚´ëŠ” í˜ì˜ ê°•ë„. ìŒìˆ˜ì—¬ì•¼ ì²™ë ¥ì…ë‹ˆë‹¤. ì ˆëŒ€ê°’ì´ í´ìˆ˜ë¡ ê°•í•˜ê²Œ ë°€ì–´ëƒ…ë‹ˆë‹¤.
            .distanceMin(25) // ì´ ê±°ë¦¬(ì›”ë“œ ìœ ë‹›)ë³´ë‹¤ ê°€ê¹Œìš´ ë…¸ë“œë“¤ë§Œ ì²™ë ¥ì´ ì ìš©ë©ë‹ˆë‹¤.
                             // ì´ ê°’ì„ ì¡°ì ˆí•˜ì—¬ ê°€ê¹Œìš´ ë…¸ë“œë“¤ì´ í©ì–´ì§€ëŠ” ì •ë„ë¥¼ ì œì–´í•©ë‹ˆë‹¤.
                             // í˜„ì¬ NODE_BASE_SCALEì´ 15ì´ë‹ˆ 20ì •ë„ê°€ ì ì ˆí•œ ì‹œì‘ì ì…ë‹ˆë‹¤.
            .distanceMax(100) // ì´ ê±°ë¦¬ë³´ë‹¤ ë¨¼ ë…¸ë“œë“¤ ì‚¬ì´ì—ëŠ” ì²™ë ¥ì´ ì ìš©ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. (ì„ íƒì )
          )
          // ì‹œë®¬ë ˆì´ì…˜ ë©ˆì¶”ëŠ” ì†ë„ ì¡°ì ˆ
          .d3AlphaDecay(0.02) // 0.1ì€ ë„ˆë¬´ ë¹¨ë¼ì„œ ë…¸ë“œë“¤ì´ ì¶©ë¶„íˆ í©ì–´ì§€ì§€ ì•Šì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
                               // 0.02 ~ 0.05 ì‚¬ì´ì˜ ë‚®ì€ ê°’ìœ¼ë¡œ ì„¤ì •í•˜ì—¬ ì¶©ë¶„íˆ í©ì–´ì§€ë„ë¡ í•©ë‹ˆë‹¤.
          .d3VelocityDecay(0.5); 

          const cam = Graph.camera();
          const zoomSlider = document.getElementById('zoom-slider');

          // ìŠ¬ë¼ì´ë” â†’ ì¹´ë©”ë¼ ìœ„ì¹˜ ë°˜ì˜
          zoomSlider.addEventListener('input', () => {
          const val = parseFloat(zoomSlider.value);
          const targetDist = sliderToCameraDist(val);
          const direction = new THREE.Vector3(0, 0, -1).applyQuaternion(cam.quaternion).normalize();

          cam.position.copy(direction.multiplyScalar(targetDist));
        });

          // ğŸ” ì¶”ê°€: ë¶€ë“œëŸ¬ìš´ ì¹´ë©”ë¼ ì´ë™ í•¨ìˆ˜
          function smoothZoomTo(sliderTargetValue) {
  const targetDist = sliderToCameraDist(sliderTargetValue); // ğŸ’¡ ìŠ¬ë¼ì´ë” ê°’ â†’ ê±°ë¦¬ ë³€í™˜
  const duration = 400;
  const startDist = cam.position.length();
  const direction = new THREE.Vector3(0, 0, -1).applyQuaternion(cam.quaternion).normalize();
  const startTime = performance.now();

  function animate(time) {
    const t = Math.min((time - startTime) / duration, 1);
    const eased = t * (2 - t); // easeOutQuad
    const current = startDist + (targetDist - startDist) * eased;
    cam.position.copy(direction.clone().multiplyScalar(current));
    zoomSlider.value = cameraDistToSlider(current); // ğŸ’¡ í˜„ì¬ ê±°ë¦¬ â†’ ìŠ¬ë¼ì´ë” ê°’
    if (t < 1) requestAnimationFrame(animate);
  }

  requestAnimationFrame(animate);
}

document.getElementById('zoom-in').addEventListener('click', () => {
  const current = parseFloat(zoomSlider.value);
  const newVal = Math.min(1500, current + 60 * 5); // ìŠ¬ë¼ì´ë” ê°’ì€ ì»¤ì§ˆìˆ˜ë¡ ì¤Œì•„ì›ƒ!
  smoothZoomTo(newVal);
});

document.getElementById('zoom-out').addEventListener('click', () => {
  const current = parseFloat(zoomSlider.value);
  const newVal = Math.max(50, current - 60 * 5);
  smoothZoomTo(newVal);
});


const sliderMin = 50;
const sliderMax = 1500;

function sliderToCameraDist(sliderValue) {
  return sliderMax - (sliderValue - sliderMin);
}

function cameraDistToSlider(cameraDist) {
  return sliderMax - (cameraDist - sliderMin);
}


          function animateZoomSync() {
            requestAnimationFrame(animateZoomSync);
            const dist = cam.position.length();
            zoomSlider.value = cameraDistToSlider(dist);
          }

          animateZoomSync();


        // ì¹´ë©”ë¼ ìœ„ì¹˜ ì„¤ì • (ì´ì „ê³¼ ë™ì¼)
        Graph.cameraPosition({ z: 250 });
        cam.position.set(0, 0, 250);
        cam.lookAt(0, 0, 0);


        Graph.renderer().domElement.addEventListener('contextmenu', function(event) {
          event.preventDefault();
        }, false);
                const controls = Graph.controls();
                console.log('ğŸš¨ controls type:', controls.constructor.name); // ì´ê±°!
                console.log(controls);

        if (controls && controls.mouseButtons) { // controls ê°ì²´ê°€ OrbitControlsì™€ ìœ ì‚¬í•œ ì†ì„±ì„ ê°€ì¡ŒëŠ”ì§€ í™•ì¸
          // ë°ìŠ¤í¬íƒ‘ ë§ˆìš°ìŠ¤ ì„¤ì •
          controls.mouseButtons.LEFT = THREE.MOUSE.ROTATE; // ì¢Œí´ë¦­ íšŒì „ (ê¸°ë³¸ê°’)
          controls.mouseButtons.MIDDLE = THREE.MOUSE.DOLLY;  // ê°€ìš´ë° í´ë¦­ ì¤Œ (ê¸°ë³¸ê°’)
          controls.mouseButtons.RIGHT = THREE.MOUSE.ROTATE;   // ìš°í´ë¦­ íŒ¬ (ê¸°ë³¸ê°’)
                                                        // ë§Œì•½ ìš°í´ë¦­ì„ íšŒì „ìœ¼ë¡œ í•˜ê³  ì‹¶ë‹¤ë©´:
                                                        // controls.mouseButtons.RIGHT = THREE.MOUSE.ROTATE;

          // íŒ¨ë‹ ë¹„í™œì„±í™” (ë§ˆìš°ìŠ¤ ë° í„°ì¹˜ì— ì˜í–¥)
          controls.noPan = true;
          controls.rotateSpeed = isMobile ? 0.85 : 0.5;

          // ì¤Œ ê±°ë¦¬ ì œí•œ
          controls.minDistance = 50;
          controls.maxDistance = 1500;



        }

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        Graph.scene().add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
        directionalLight.position.set(1, 1, 1);
        Graph.scene().add(directionalLight);

        function onMouseMoveTooltip(event) {
            if (hoveredNode) {
                tooltipElement.style.left = (event.clientX + 10) + 'px';
                tooltipElement.style.top = (event.clientY + 10) + 'px';
            } else {
                tooltipElement.style.display = 'none';
            }
        }
        
        setTimeout(() => {
            const { nodes: graphNodes } = Graph.graphData();
            if (graphNodes.length) {
                let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity, minZ = Infinity, maxZ = -Infinity;
                graphNodes.forEach(n => {
                    // D3 Force ì‹œë®¬ë ˆì´ì…˜ì´ ëë‚œ í›„ì˜ ìµœì¢… ìœ„ì¹˜ (n.x, n.y, n.z)ë¥¼ ì‚¬ìš©
                    minX = Math.min(minX, n.x); maxX = Math.max(maxX, n.x);
                    minY = Math.min(minY, n.y); maxY = Math.max(maxY, n.y);
                    minZ = Math.min(minZ, n.z); maxZ = Math.max(maxZ, n.z);
                });

                const centerX = (minX + maxX) / 2;
                const centerY = (minY + maxY) / 2;
                const centerZ = (minZ + maxZ) / 2;
                const maxExtent = Math.max(maxX - minX, maxY - minY, maxZ - minZ);
                const camera = Graph.camera();
                if (camera) {
                    let camDistance = maxExtent / (2 * Math.tan(Math.PI * camera.fov / 360));
                    camDistance = Math.max(camDistance, 100);
                    camDistance = Math.min(camDistance, 2000);
                    Graph.cameraPosition(
                        { x: centerX, y: centerY, z: centerZ + 1500 },
                        { x: centerX, y: centerY, z: centerZ },
                        1000
                    );
                } else {
                     console.warn("ì¹´ë©”ë¼ ê°ì²´ë¥¼ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ì–´ ìë™ ìœ„ì¹˜ ì¡°ì •ì„ ìƒëµí•©ë‹ˆë‹¤.");
                     Graph.cameraPosition({ z: 400 + Math.max(maxX-minX, maxY-minY, maxZ-minZ) });
                }
            } else {
                Graph.cameraPosition({ x:0, y:0, z: 1500 });
            }
        }, 1000);

        window.addEventListener('resize', () => {
            Graph.width(window.innerWidth);
            Graph.height(window.innerHeight);
        });

    }).catch(error => {
      console.error("ë°ì´í„° ë¡œë”© ë˜ëŠ” ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ:", error);
      const container = document.getElementById('graph-container');
      container.innerHTML = `<p style="color: red; text-align: center; padding-top: 50px;">ë°ì´í„° ë¡œë”© ì‹¤íŒ¨: ${error.message}</p>`;
    });

  </script>
</body>
</html>
