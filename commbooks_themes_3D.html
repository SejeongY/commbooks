<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>ì»¤ë®¤ë‹ˆì¼€ì´ì…˜ë¶ìŠ¤ ì§€ì‹ì—°ê²°ì§€ë„</title>
  <style>
    html, body { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #f5f0e6; }
    #graph-container { width: 100%; height: 100%; }
    .node-tooltip {
      position: absolute;
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 5px;
      border-radius: 3px;
      pointer-events: none; /* crucial for mouse events to pass through to the canvas */
      font-family: sans-serif;
      font-size: 12px;
    }
    .scene-nav-info {
      display: none !important;
    }

    #zoom-controls {
    position: absolute;
    bottom: 20px; /* âœ… ìƒë‹¨ ëŒ€ì‹  í•˜ë‹¨ì— ë°°ì¹˜ */
    right: 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 6px;
    z-index: 10;
  }


    #zoom-controls button {
    font-size: 15px;
    padding: 10px 14px;
    background-color: #ffffffcc;
    border: 1px solid #aaa;
    border-radius: 6px;
    cursor: pointer;
    box-shadow: 1px 1px 4px rgba(0,0,0,0.2);
    touch-action: manipulation; /* âœ… ëª¨ë°”ì¼ í„°ì¹˜ ê°œì„  */
  }

  #zoom-slider {
    writing-mode: bt-lr;
    -webkit-appearance: slider-vertical;
    width: 30px;
    height: 150px;
    margin: 6px auto;
    background: transparent;
    touch-action: none; /* âœ… ëª¨ë°”ì¼ì—ì„œ ì˜ë„ì¹˜ ì•Šì€ ìŠ¤í¬ë¡¤ ë°©ì§€ */
  }

@media (max-width: 768px) {
  #zoom-slider {
    width: 20px;
    height: 100px;
  }
}


  </style>
  <link rel="preload" href="tags_3d_A.json" as="fetch" crossorigin="anonymous">
</head>
<body>
  <div id="graph-container"></div>
  <div id="node-tooltip" class="node-tooltip" style="display: none;"></div>
  <div id="zoom-controls">
    <button id="zoom-in">ï¼‹</button>
    <input type="range" id="zoom-slider" min="50" max="1500" step="60" value="250">
    <button id="zoom-out">ï¼</button>
  </div>
  

  <script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/3d-force-graph@1.71.3/dist/3d-force-graph.min.js"></script>
  <script src="https://d3js.org/d3.v7.min.js"></script> 

  <script>

    let preloadDataPromise = fetch("tags_3d_A.json")
      .then(res => res.json())
      .catch(error => {
        console.error("í”„ë¦¬ë¡œë“œ ì‹¤íŒ¨:", error);
        return []; // ì‹¤íŒ¨í•´ë„ ë¹ˆ ë°°ì—´ ë°˜í™˜í•´ì„œ ì´í›„ ì˜¤ë¥˜ ë°©ì§€
      });


    const pastelColors = [
    "#F78C8C", "#E885A7", "#D899EA", "#AE9CF0", // Red, Pink, Muted Grape, Muted Violet
  "#98A9F7", "#79B5F0", "#6FCEDD", "#4DD4A8", // Muted Indigo, Muted Blue, Muted Cyan, Teal
  "#72D986", "#ADDD50", "#FDD045", "#FFA85C", // Green, Lime, Yellow, Orange
  "#F78C8C", "#C2E678", "#90C3F6", "#E6B0F4", // Red (Repeat), Muted Green, Muted Bright Blue, Muted Bright Purple
  "#FFA0A0", "#A8D2F8", "#F0C2F9", "#FDE06F"  // Lighter Red, Muted Lighter Blue, Muted Lighter Purple, Lighter Yellow
];

    const FONT_SIZE = 11;
    const PADDING_X = 10;
    const PADDING_Y = 5;
    const BORDER_RADIUS = 16;
    const HOVER_SCALE_FACTOR = 1; 
    const NODE_BASE_SCALE = 22.5;

    const tooltipElement = document.getElementById('node-tooltip');
    const textureCache = new Map();
    const TEXTURE_RESOLUTION_SCALE = 1.5; 

    function drawRoundedRect(ctx, x, y, w, h, r, isHovered) {
        if (w < 2 * r) r = w / 2;
        if (h < 2 * r) r = h / 2;
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.arcTo(x + w, y, x + w, y + h, r);
        ctx.arcTo(x + w, y + h, x, y + h, r);
        ctx.arcTo(x, y + h, x, y, r);
        ctx.arcTo(x, y, x + w, y, r);
        ctx.closePath();

        if (isHovered) {
            ctx.shadowColor = "rgba(0,0,0,0.3)";
            ctx.shadowBlur = 8;
            ctx.shadowOffsetX = 3;
            ctx.shadowOffsetY = 3;
        } else {
            ctx.shadowColor = "rgba(0,0,0,0.15)";
            ctx.shadowBlur = 5;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;
        }
        ctx.fill();
        ctx.shadowColor = "transparent"; 
    }
    
    function drawRoundedRectInternal(ctx, x, y, w, h, r) {
        if (w < 2 * r) r = w / 2;
        if (h < 2 * r) r = h / 2;
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.arcTo(x + w, y, x + w, y + h, r);
        ctx.arcTo(x + w, y + h, x, y + h, r);
        ctx.arcTo(x, y + h, x, y, r);
        ctx.arcTo(x, y, x + w, y, r);
        ctx.closePath();
        ctx.fill();
    }


    function getNodeTexture(node, colorStr, isHovered = false) {
        const cacheKey = `${node.id}-${colorStr}-${isHovered}-${TEXTURE_RESOLUTION_SCALE}`;
        if (textureCache.has(cacheKey)) {
            return textureCache.get(cacheKey);
        }

        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        let currentFontSize = FONT_SIZE * TEXTURE_RESOLUTION_SCALE;
        let currentPaddingX = PADDING_X * TEXTURE_RESOLUTION_SCALE;
        let currentPaddingY = PADDING_Y * TEXTURE_RESOLUTION_SCALE;
        let currentBorderRadius = BORDER_RADIUS * TEXTURE_RESOLUTION_SCALE;

        let text = node.id;

        ctx.font = `${currentFontSize}px sans-serif`;
        const textMetrics = ctx.measureText(text);
        
        let nodeContentWidth = textMetrics.width + currentPaddingX * 2;
        let nodeContentHeight = currentFontSize + currentPaddingY * 2;

        const hoverScaleEffect = isHovered ? HOVER_SCALE_FACTOR : 1;
        const shadowBlurEffect = 5 * TEXTURE_RESOLUTION_SCALE;
        const shadowOffsetEffect = 2 * TEXTURE_RESOLUTION_SCALE;
        const extraPaddingForShadow = Math.max(shadowBlurEffect + Math.abs(shadowOffsetEffect), 5 * TEXTURE_RESOLUTION_SCALE);

        canvas.width = nodeContentWidth + extraPaddingForShadow * 2;
        canvas.height = nodeContentHeight + extraPaddingForShadow * 2;
        
        const drawX = extraPaddingForShadow;
        const drawY = extraPaddingForShadow;

        ctx.shadowColor = "rgba(0,0,0,0.15)";
        ctx.shadowBlur = 5 * TEXTURE_RESOLUTION_SCALE;
        ctx.shadowOffsetX = 2 * TEXTURE_RESOLUTION_SCALE;
        ctx.shadowOffsetY = 2 * TEXTURE_RESOLUTION_SCALE;

        function getDarkerColor(hex, factor = 1.05) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            const darker = (c) => Math.max(0, Math.min(255, Math.floor(c * factor)));
            return `rgb(${darker(r)}, ${darker(g)}, ${darker(b)})`;
        }

        const bgColor = isHovered ? getDarkerColor(colorStr) : colorStr;
        ctx.fillStyle = bgColor;
        drawRoundedRectInternal(ctx, drawX, drawY, nodeContentWidth, nodeContentHeight, currentBorderRadius);

        ctx.shadowColor = "transparent";
        ctx.fillStyle = isHovered ? '#000000' : '#000000';
        ctx.font = `${currentFontSize}px sans-serif`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(text, drawX + nodeContentWidth / 2, drawY + nodeContentHeight / 2);
        
        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        textureCache.set(cacheKey, texture);
        return texture;
    }


    preloadDataPromise.then(data => {
        const INITIAL_COORDINATE_SCALE_FACTOR = 100;
        const nodes = data.map(d => ({
            id: d.id,
            name: d.id,
            group: d.group,
            x: d.x * INITIAL_COORDINATE_SCALE_FACTOR,
            y: d.y * INITIAL_COORDINATE_SCALE_FACTOR,
            z: d.z * INITIAL_COORDINATE_SCALE_FACTOR,
            url: `http://commbooks.com/ë„ì„œ-íƒœê·¸/${encodeURIComponent(d.id.replace(/\s+/g, '-'))}`,
            val: 0.5
        }));

        const graphData = { nodes, links: [] };
        let hoveredNode = null;
        const isMobile = /Mobi|Android/i.test(navigator.userAgent);
        let isTouchZooming = false;
        let touchStartTime = 0;
        let lastTouchCount = 0;

        document.addEventListener('touchstart', (e) => {
            touchStartTime = Date.now();
            lastTouchCount = e.touches.length;
            if (e.touches.length > 1) isTouchZooming = true;
        }, { passive: true });

        document.addEventListener('touchend', (e) => {
            const touchDuration = Date.now() - touchStartTime;
            if (lastTouchCount > 1 || touchDuration > 1000) {
                setTimeout(() => { isTouchZooming = false; }, 200);
            } else {
                isTouchZooming = false;
            }
        }, { passive: true });

        document.addEventListener('touchmove', (e) => {
            if (e.touches.length > 1) isTouchZooming = true;
        }, { passive: true });

        const Graph = ForceGraph3D()
            (document.getElementById('graph-container'))
            .graphData(graphData)
            .nodeLabel(null)
            .nodeColor(node => pastelColors[node.group % pastelColors.length])
            .backgroundColor('#f5f0e6')
            .enableNodeDrag(false)
            .nodeThreeObject(node => {
                const colorStr = pastelColors[node.group % pastelColors.length];
                const isHovered = hoveredNode === node;
                const material = new THREE.SpriteMaterial({
                    map: getNodeTexture(node, colorStr, isHovered),
                    transparent: true,
                    depthWrite: false,
                });
                const sprite = new THREE.Sprite(material);
                const canvasForTexture = getNodeTexture(node, colorStr, isHovered).image;
                const spriteWidth = canvasForTexture.width;
                const spriteHeight = canvasForTexture.height;
                let scale = NODE_BASE_SCALE * (isHovered ? HOVER_SCALE_FACTOR : 1);
                sprite.scale.set(spriteWidth * scale / 100, spriteHeight * scale / 100, 1);
                sprite.userData = { node, baseScaleX: sprite.scale.x, baseScaleY: sprite.scale.y };
                return sprite;
            })
            .onNodeHover(node => {
                const container = document.getElementById('graph-container');
                if (hoveredNode === node && node !== null) return;
                
                if (hoveredNode) {
                    const prevSprite = hoveredNode.__threeObj;
                    if (prevSprite) {
                        const colorStr = pastelColors[hoveredNode.group % pastelColors.length];
                        if (prevSprite.material.map) prevSprite.material.map.dispose();
                        prevSprite.material.map = getNodeTexture(hoveredNode, colorStr, false);
                        prevSprite.scale.set(prevSprite.userData.baseScaleX, prevSprite.userData.baseScaleY, 1);
                    }
                }
                
                hoveredNode = node;

                if (node) {
                    const currentSprite = node.__threeObj;
                    if (currentSprite) {
                        const colorStr = pastelColors[node.group % pastelColors.length];
                        if (currentSprite.material.map) currentSprite.material.map.dispose();
                        currentSprite.material.map = getNodeTexture(node, colorStr, true);
                        currentSprite.scale.set(
                            currentSprite.userData.baseScaleX * HOVER_SCALE_FACTOR, 
                            currentSprite.userData.baseScaleY * HOVER_SCALE_FACTOR, 
                            1
                        );
                    }
                    container.style.cursor = 'pointer';
                    if (!isMobile) {
                        tooltipElement.style.display = 'block';
                        tooltipElement.innerHTML = node.name;
                    } else {
                        tooltipElement.style.display = 'none';
                    }
                } else {
                    container.style.cursor = 'grab';
                    tooltipElement.style.display = 'none';
                }
                Graph.renderer().domElement.addEventListener('mousemove', onMouseMoveTooltip, false);
            })
            .onNodeClick(node => {
                if (isTouchZooming) return;
                if (node.url) window.open(node.url, '_blank');
            })
            .d3Force('charge', d3.forceManyBody().strength(-2).distanceMin(25).distanceMax(100))
            .d3AlphaDecay(0.02)
            .d3VelocityDecay(0.5); 

        const cam = Graph.camera();
        const controls = Graph.controls(); // ì»¨íŠ¸ë¡¤ ê°ì²´ ê°€ì ¸ì˜¤ê¸°
        const zoomSlider = document.getElementById('zoom-slider');

        const sliderMin = parseFloat(zoomSlider.min);
        const sliderMax = parseFloat(zoomSlider.max);
        // ìŠ¬ë¼ì´ë”ì˜ ì‹œê°ì  í‘œí˜„ê³¼ ì‹¤ì œ ì¹´ë©”ë¼ ê±°ë¦¬ë¥¼ ë§¤í•‘í•©ë‹ˆë‹¤.
        // ìŠ¬ë¼ì´ë” ê°’ì´ í´ìˆ˜ë¡ -> ì¹´ë©”ë¼ ê±°ë¦¬ê°€ ê°€ê¹Œì›Œì§ (ì¤Œ ì¸)
        // ìŠ¬ë¼ì´ë” ê°’ì´ ì‘ì„ìˆ˜ë¡ -> ì¹´ë©”ë¼ ê±°ë¦¬ê°€ ë©€ì–´ì§ (ì¤Œ ì•„ì›ƒ)
        // controls.minDistance ì™€ controls.maxDistance ë¥¼ í™œìš©í•˜ì—¬ ì‹¤ì œ ì¹´ë©”ë¼ í—ˆìš© ë²”ìœ„ì™€ ì¼ì¹˜ì‹œí‚´
        // ì´ í•¨ìˆ˜ë“¤ì€ ìŠ¬ë¼ì´ë” ê°’ê³¼ ì‹¤ì œ "ì¹´ë©”ë¼-íƒ€ê²Ÿ ê°„ ê±°ë¦¬"ë¥¼ ë³€í™˜í•©ë‹ˆë‹¤.
        function sliderToCameraDist(sliderValue) {
            // ìŠ¬ë¼ì´ë” ë²”ìœ„ë¥¼ [0, 1]ë¡œ ì •ê·œí™”
            const normalizedSlider = (sliderValue - sliderMin) / (sliderMax - sliderMin);
            // ì¹´ë©”ë¼ ê±°ë¦¬ ë²”ìœ„ë¥¼ [minDistance, maxDistance]ë¡œ ë§¤í•‘ (ìŠ¬ë¼ì´ë”ê°€ í¬ë©´ ê±°ë¦¬ê°€ ì‘ì•„ì§)
            return controls.maxDistance - normalizedSlider * (controls.maxDistance - controls.minDistance);
        }

        function cameraDistToSlider(cameraDist) {
            // ì¹´ë©”ë¼ ê±°ë¦¬ë¥¼ [0, 1]ë¡œ ì •ê·œí™” (ê±°ë¦¬ê°€ ì‘ì„ìˆ˜ë¡ 0ì— ê°€ê¹Œì›€)
            const normalizedDist = (cameraDist - controls.minDistance) / (controls.maxDistance - controls.minDistance);
            // ìŠ¬ë¼ì´ë” ê°’ìœ¼ë¡œ ë³€í™˜ (ê±°ë¦¬ê°€ ì‘ì„ìˆ˜ë¡ ìŠ¬ë¼ì´ë” ê°’ì´ ì»¤ì§)
            return sliderMin + (1 - normalizedDist) * (sliderMax - sliderMin);
        }
        
        // ì´ˆê¸° ìŠ¬ë¼ì´ë” ê°’ ì„¤ì • (ì¹´ë©”ë¼ ì´ˆê¸° ìœ„ì¹˜ ê¸°ë°˜)
        // Graph.cameraPosition({ z: 250 })ìœ¼ë¡œ ì´ˆê¸°í™”ë˜ë¯€ë¡œ, ì´ ê°’ì„ ì‚¬ìš©
        const initialCameraZ = 250; 
        // controls.targetì€ ê¸°ë³¸ì ìœ¼ë¡œ (0,0,0)
        const initialTarget = new THREE.Vector3(0,0,0); // Graph.controls().target ìœ¼ë¡œ ê°€ì ¸ì˜¤ëŠ”ê²Œ ë” ì •í™•
        const initialDistance = new THREE.Vector3(0,0,initialCameraZ).distanceTo(initialTarget);
        zoomSlider.value = cameraDistToSlider(initialDistance);


        // ë¶€ë“œëŸ¬ìš´ ì¹´ë©”ë¼ ì¤Œ í•¨ìˆ˜
        function smoothZoomTo(targetSliderValue) {
            const targetCameraDistance = sliderToCameraDist(targetSliderValue);
            const duration = 300; // ì• ë‹ˆë©”ì´ì…˜ ì§€ì† ì‹œê°„ (ms)
            const lookAtTarget = controls.target; // í˜„ì¬ ì¹´ë©”ë¼ê°€ ë°”ë¼ë³´ëŠ” ì§€ì 
            
            const startCameraDistance = cam.position.distanceTo(lookAtTarget);
            const startTime = performance.now();

            // ì‹œì‘ ì‹œì , íƒ€ê²Ÿì—ì„œ ì¹´ë©”ë¼ë¡œ í–¥í•˜ëŠ” ë°©í–¥ ë²¡í„° (ì •ê·œí™”)
            let startDirectionToCamera;
            if (startCameraDistance < 0.001) { // ì¹´ë©”ë¼ê°€ íƒ€ê²Ÿê³¼ ë§¤ìš° ê°€ê¹Œìš¸ ë•Œ
                // ì¹´ë©”ë¼ê°€ íƒ€ê²Ÿ ìœ„ì— ìˆë‹¤ë©´, ê¸°ë³¸ ë°©í–¥ìœ¼ë¡œ (ì˜ˆ: íƒ€ê²Ÿ ë’¤ìª½)
                startDirectionToCamera = new THREE.Vector3(0, 0, 1); 
            } else {
                startDirectionToCamera = new THREE.Vector3().subVectors(cam.position, lookAtTarget).normalize();
            }

            function animate(time) {
                const t = Math.min((time - startTime) / duration, 1);
                const easedT = t * (2 - t); // easeOutQuad

                const currentCameraDistance = startCameraDistance + (targetCameraDistance - startCameraDistance) * easedT;
                
                // minDistance, maxDistance ë²”ìœ„ ë‚´ë¡œ ê±°ë¦¬ ì œí•œ
                const clampedDistance = Math.max(controls.minDistance, Math.min(controls.maxDistance, currentCameraDistance));

                const newCamPos = new THREE.Vector3().copy(lookAtTarget).addScaledVector(startDirectionToCamera, clampedDistance);
                
                cam.position.copy(newCamPos);
                // controls.update(); // TrackballControlsì˜ ê²½ìš° ìˆ˜ë™ ì—…ë°ì´íŠ¸ í•„ìš”í•  ìˆ˜ ìˆìŒ

                const actualDistance = cam.position.distanceTo(lookAtTarget);
                zoomSlider.value = cameraDistToSlider(actualDistance);

                if (t < 1) {
                    requestAnimationFrame(animate);
                } else {
                    // ì• ë‹ˆë©”ì´ì…˜ ì¢…ë£Œ í›„ ìµœì¢…ê°’ìœ¼ë¡œ ì •í™•íˆ ì„¤ì •
                    const finalPos = new THREE.Vector3().copy(lookAtTarget).addScaledVector(startDirectionToCamera, targetCameraDistance);
                    cam.position.copy(finalPos);
                    // controls.update();
                    zoomSlider.value = cameraDistToSlider(targetCameraDistance);
                }
            }
            requestAnimationFrame(animate);
        }

        document.getElementById('zoom-in').addEventListener('click', () => {
            const currentSliderValue = parseFloat(zoomSlider.value);
            // ìŠ¬ë¼ì´ë” ê°’ ì¦ê°€ëŠ” ì¤Œì¸ (ì¹´ë©”ë¼ ê±°ë¦¬ ê°ì†Œ)
            const newSliderValue = Math.min(sliderMax, currentSliderValue + parseFloat(zoomSlider.step) * 5);
            smoothZoomTo(newSliderValue);
        });

        document.getElementById('zoom-out').addEventListener('click', () => {
            const currentSliderValue = parseFloat(zoomSlider.value);
            // ìŠ¬ë¼ì´ë” ê°’ ê°ì†ŒëŠ” ì¤Œì•„ì›ƒ (ì¹´ë©”ë¼ ê±°ë¦¬ ì¦ê°€)
            const newSliderValue = Math.max(sliderMin, currentSliderValue - parseFloat(zoomSlider.step) * 5);
            smoothZoomTo(newSliderValue);
        });
        
        // ìŠ¬ë¼ì´ë” ì§ì ‘ ì¡°ì‘ ì‹œ
        zoomSlider.addEventListener('input', () => {
            const sliderValue = parseFloat(zoomSlider.value);
            const targetCameraDistance = sliderToCameraDist(sliderValue);
            const lookAtTarget = controls.target;
            const currentCamDistance = cam.position.distanceTo(lookAtTarget);

            let directionToCamera;
            if (currentCamDistance < 0.001) {
                directionToCamera = new THREE.Vector3(0, 0, 1);
            } else {
                directionToCamera = new THREE.Vector3().subVectors(cam.position, lookAtTarget).normalize();
            }
            
            // minDistance, maxDistance ë²”ìœ„ ë‚´ë¡œ ê±°ë¦¬ ì œí•œ
            const clampedDistance = Math.max(controls.minDistance, Math.min(controls.maxDistance, targetCameraDistance));

            const newCamPos = new THREE.Vector3().copy(lookAtTarget).addScaledVector(directionToCamera, clampedDistance);
            cam.position.copy(newCamPos);
            // controls.update();
        });

        // ì¹´ë©”ë¼ ì›€ì§ì„(ìŠ¤í¬ë¡¤ ì¤Œ ë“±)ì— ë”°ë¼ ìŠ¬ë¼ì´ë” ë™ê¸°í™”
        function animateZoomSync() {
            requestAnimationFrame(animateZoomSync);
            if (controls && controls.target) { // controls ê°ì²´ ë° target ì†ì„± í™•ì¸
                 const dist = cam.position.distanceTo(controls.target);
                 // ìŠ¬ë¼ì´ë” ì—…ë°ì´íŠ¸ ì‹œ ë£¨í”„ ë°©ì§€ë¥¼ ìœ„í•´ í˜„ì¬ ê°’ê³¼ ë‹¤ë¥¼ ë•Œë§Œ ì—…ë°ì´íŠ¸
                 const newSliderValue = cameraDistToSlider(dist);
                 if (Math.abs(parseFloat(zoomSlider.value) - newSliderValue) > 0.1) { // ì•½ê°„ì˜ ì˜¤ì°¨ í—ˆìš©
                    zoomSlider.value = newSliderValue;
                 }
            }
        }
        animateZoomSync();

        Graph.cameraPosition({ z: initialCameraZ }); // ì´ˆê¸° ì¹´ë©”ë¼ ìœ„ì¹˜ ì„¤ì •
        // cam.lookAt(0,0,0)ì€ controlsê°€ ê´€ë¦¬

        Graph.renderer().domElement.addEventListener('contextmenu', event => event.preventDefault(), false);
        
        console.log('ğŸš¨ controls type:', controls.constructor.name);
        // console.log(controls);

        if (controls && controls.mouseButtons) {
            controls.mouseButtons.LEFT = THREE.MOUSE.ROTATE;
            controls.mouseButtons.MIDDLE = THREE.MOUSE.DOLLY;
            controls.mouseButtons.RIGHT = THREE.MOUSE.ROTATE; // ìš°í´ë¦­ íšŒì „
            controls.enablePan = false; // íŒ¨ë‹ ë¹„í™œì„±í™” (noPanì€ ì˜¤ë˜ëœ ì†ì„±ì¼ ìˆ˜ ìˆìŒ)
            controls.rotateSpeed = isMobile ? 0.85 : 0.5;
            controls.minDistance = 50;  // ìµœì†Œ ì¤Œ ê±°ë¦¬
            controls.maxDistance = 1500; // ìµœëŒ€ ì¤Œ ê±°ë¦¬
        } else if (controls) { // TrackballControls ë“± ë‹¤ë¥¸ ì»¨íŠ¸ë¡¤ëŸ¬ì˜ ê²½ìš°
            controls.noPan = true; // íŒ¨ë‹ ë¹„í™œì„±í™”
            controls.rotateSpeed = isMobile ? 2.0 : 1.2; // TrackballControlsëŠ” rotateSpeed ìŠ¤ì¼€ì¼ì´ ë‹¤ë¦„
            controls.zoomSpeed = 1.2;
            controls.minDistance = 50;
            controls.maxDistance = 1500;
            // TrackballControlsëŠ” mouseButtons ì§ì ‘ ì„¤ì • ë°©ì‹ì´ ë‹¤ë¦„ (í•„ìš”ì‹œ ì¶”ê°€ ì„¤ì •)
        }


        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        Graph.scene().add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
        directionalLight.position.set(1, 1, 1);
        Graph.scene().add(directionalLight);

        function onMouseMoveTooltip(event) {
            if (hoveredNode) {
                tooltipElement.style.left = (event.clientX + 10) + 'px';
                tooltipElement.style.top = (event.clientY + 10) + 'px';
            } else {
                tooltipElement.style.display = 'none';
            }
        }
        
        setTimeout(() => {
            if (!isMobile) return; 

            const { nodes: graphNodes } = Graph.graphData();
            if (graphNodes.length) {
                let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity, minZ = Infinity, maxZ = -Infinity;
                graphNodes.forEach(n => {
                    minX = Math.min(minX, n.x); maxX = Math.max(maxX, n.x);
                    minY = Math.min(minY, n.y); maxY = Math.max(maxY, n.y);
                    minZ = Math.min(minZ, n.z); maxZ = Math.max(maxZ, n.z);
                });

                const centerX = (minX + maxX) / 2;
                const centerY = (minY + maxY) / 2;
                const centerZ = (minZ + maxZ) / 2;
                
                // ì¹´ë©”ë¼ ìœ„ì¹˜ ë° ë°”ë¼ë³´ëŠ” ì§€ì  ì„¤ì •
                // ì´ ì„¤ì • í›„ controls.targetì€ (centerX, centerY, centerZ)ê°€ ë¨
                Graph.cameraPosition(
                    { x: centerX, y: centerY, z: centerZ + 1500 }, // ì¹´ë©”ë¼ ìœ„ì¹˜
                    { x: centerX, y: centerY, z: centerZ },      // ë°”ë¼ë³´ëŠ” ì§€ì  (lookAt)
                    1000                                          // ì „í™˜ ì‹œê°„
                );
                // cameraPosition í˜¸ì¶œ í›„ controls.targetì´ ì—…ë°ì´íŠ¸ë˜ë¯€ë¡œ, ìŠ¬ë¼ì´ë” ê°’ë„ ì¬ì¡°ì • í•„ìš”
                setTimeout(() => {
                    if (controls && controls.target) {
                         const dist = cam.position.distanceTo(controls.target);
                         zoomSlider.value = cameraDistToSlider(dist);
                    }
                }, 1100); // cameraPosition ì• ë‹ˆë©”ì´ì…˜ ì‹œê°„ë³´ë‹¤ ì•½ê°„ ê¸¸ê²Œ

            } else {
                Graph.cameraPosition({ x: 0, y: 0, z: 1500 });
            }
        }, 1000);

        window.addEventListener('resize', () => {
            Graph.width(window.innerWidth);
            Graph.height(window.innerHeight);
        });

    }).catch(error => {
      console.error("ë°ì´í„° ë¡œë”© ë˜ëŠ” ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ:", error);
      const container = document.getElementById('graph-container');
      container.innerHTML = `<p style="color: red; text-align: center; padding-top: 50px;">ë°ì´í„° ë¡œë”© ì‹¤íŒ¨: ${error.message}</p>`;
    });

  </script>
</body>
</html>
