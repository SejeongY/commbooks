<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>ì»¤ë®¤ë‹ˆì¼€ì´ì…˜ë¶ìŠ¤ ì§€ì‹ì—°ê²°ì§€ë„</title>
  <style>
    html, body { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #f5f0e6; }
    #graph-container { width: 100%; height: 100%; }
    .node-tooltip {
      position: absolute;
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 5px;
      border-radius: 3px;
      pointer-events: none; /* crucial for mouse events to pass through to the canvas */
      font-family: sans-serif;
      font-size: 12px;
    }
    .scene-nav-info {
      display: none !important;
    }
  </style>
</head>
<body>
  <div id="graph-container"></div>
  <div id="node-tooltip" class="node-tooltip" style="display: none;"></div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/3d-force-graph@1.71.3/dist/3d-force-graph.min.js"></script>
  <script src="https://d3js.org/d3.v7.min.js"></script> 

  <script>
    const pastelColors = [
      "#FFCDD2", "#F8BBD0", "#E1BEE7", "#D1C4E9",
      "#C5CAE9", "#BBDEFB", "#B3E5FC", "#B2EBF2",
      "#B2DFDB", "#C8E6C9", "#DCEDC8", "#F0F4C3",
      "#FFF9C4", "#FFECB3", "#FFE0B2", "#FFCCBC",
      "#D7CCC8", "#CFD8DC", "#F5E0DC", "#E0E0E0"
    ];

    const FONT_SIZE = 11;
    const PADDING_X = 10;
    const PADDING_Y = 5;
    const BORDER_RADIUS = 16;
    const HOVER_SCALE_FACTOR = 1; // í™•ëŒ€ íš¨ê³¼ëŠ” ë‹¤ì‹œ ì ìš©ë©ë‹ˆë‹¤. (ì›ë˜ ì½”ë“œë¡œ íšŒê·€)
    const NODE_BASE_SCALE = 15;

    const tooltipElement = document.getElementById('node-tooltip');

    // Cache for node textures
    const textureCache = new Map();
    const TEXTURE_RESOLUTION_SCALE = 2; // í•´ìƒë„ ë°°ìœ¨ì„ 2ë¡œ ë‚®ì¶°ì„œ ì„±ëŠ¥ ë¶€ë‹´ì„ ì¤„ì´ê³  í…ŒìŠ¤íŠ¸í•´ ë³´ì„¸ìš”.

    // drawRoundedRectì™€ drawRoundedRectInternalì€ ì›ë³¸ ì½”ë“œë¥¼ ìœ ì§€í•©ë‹ˆë‹¤.
    function drawRoundedRect(ctx, x, y, w, h, r, isHovered) {
        if (w < 2 * r) r = w / 2;
        if (h < 2 * r) r = h / 2;
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.arcTo(x + w, y, x + w, y + h, r);
        ctx.arcTo(x + w, y + h, x, y + h, r);
        ctx.arcTo(x, y + h, x, y, r);
        ctx.arcTo(x, y, x + w, y, r);
        ctx.closePath();

        if (isHovered) {
            ctx.shadowColor = "rgba(0,0,0,0.3)";
            ctx.shadowBlur = 8;
            ctx.shadowOffsetX = 3;
            ctx.shadowOffsetY = 3;
        } else {
            ctx.shadowColor = "rgba(0,0,0,0.15)";
            ctx.shadowBlur = 5;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;
        }
        ctx.fill();
        ctx.shadowColor = "transparent"; // Reset shadow for text
    }
    
    function drawRoundedRectInternal(ctx, x, y, w, h, r) {
        if (w < 2 * r) r = w / 2;
        if (h < 2 * r) r = h / 2;
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.arcTo(x + w, y, x + w, y + h, r);
        ctx.arcTo(x + w, y + h, x, y + h, r);
        ctx.arcTo(x, y + h, x, y, r);
        ctx.arcTo(x, y, x + w, y, r);
        ctx.closePath();
        ctx.fill();
    }


    function getNodeTexture(node, colorStr, isHovered = false) {
        const cacheKey = `${node.id}-${colorStr}-${isHovered}-${TEXTURE_RESOLUTION_SCALE}`;
        if (textureCache.has(cacheKey)) {
            return textureCache.get(cacheKey);
        }

        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        let currentFontSize = FONT_SIZE * TEXTURE_RESOLUTION_SCALE;
        let currentPaddingX = PADDING_X * TEXTURE_RESOLUTION_SCALE;
        let currentPaddingY = PADDING_Y * TEXTURE_RESOLUTION_SCALE;
        let currentBorderRadius = BORDER_RADIUS * TEXTURE_RESOLUTION_SCALE;

        let text = node.id;

        ctx.font = `${currentFontSize}px sans-serif`;
        const textMetrics = ctx.measureText(text);
        
        let nodeContentWidth = textMetrics.width + currentPaddingX * 2;
        let nodeContentHeight = currentFontSize + currentPaddingY * 2;

        const hoverScaleEffect = isHovered ? HOVER_SCALE_FACTOR : 1;
        const shadowBlurEffect = 5 * TEXTURE_RESOLUTION_SCALE;
        const shadowOffsetEffect = 2 * TEXTURE_RESOLUTION_SCALE;

        const extraPaddingForShadow = Math.max(shadowBlurEffect + Math.abs(shadowOffsetEffect), 5 * TEXTURE_RESOLUTION_SCALE);


        canvas.width = nodeContentWidth + extraPaddingForShadow * 2;
        canvas.height = nodeContentHeight + extraPaddingForShadow * 2;
        
        const drawX = extraPaddingForShadow;
        const drawY = extraPaddingForShadow;

              // ğŸ¯ ê·¸ë¦¼ì íš¨ê³¼ ê³ ì •
        ctx.shadowColor = "rgba(0,0,0,0.15)";
        ctx.shadowBlur = 5 * TEXTURE_RESOLUTION_SCALE;
        ctx.shadowOffsetX = 2 * TEXTURE_RESOLUTION_SCALE;
        ctx.shadowOffsetY = 2 * TEXTURE_RESOLUTION_SCALE;

        function getDarkerColor(hex, factor = 1.05) {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        const darker = (c) => Math.max(0, Math.min(255, Math.floor(c * factor)));
        return `rgb(${darker(r)}, ${darker(g)}, ${darker(b)})`;
      }


        const bgColor = isHovered ? getDarkerColor(colorStr) : colorStr;
        ctx.fillStyle = bgColor;
        drawRoundedRectInternal(ctx, drawX, drawY, nodeContentWidth, nodeContentHeight, currentBorderRadius);


        ctx.shadowColor = "transparent";

        ctx.fillStyle = isHovered ? '#000000' : '#333';
        ctx.font = `${currentFontSize}px sans-serif`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(text, drawX + nodeContentWidth / 2, drawY + nodeContentHeight / 2);
        
        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        textureCache.set(cacheKey, texture);
        return texture;
    }


    fetch("tags_3d_A.json")
      .then(res => res.json())
      .then(data => {
        // â˜…â˜…â˜… ë…¸ë“œ ê°„ ê±°ë¦¬ ì¡°ì ˆì„ ìœ„í•œ ë³€ê²½ ì‚¬í•­ â˜…â˜…â˜…
        const INITIAL_COORDINATE_SCALE_FACTOR = 100; // ì´ˆê¸° ì¢Œí‘œ ìŠ¤ì¼€ì¼ë§ íŒ©í„° (ì—¬ì „íˆ ì „ë°˜ì ì¸ ë¶„í¬ì— ì˜í–¥)

        const nodes = data.map(d => ({
          id: d.id,
          name: d.id,
          group: d.group,
          // â˜…â˜…â˜… fx, fy, fz ëŒ€ì‹  x, y, zë¡œ ì´ˆê¸° ìœ„ì¹˜ë§Œ ì§€ì • â˜…â˜…â˜…
          x: d.x * INITIAL_COORDINATE_SCALE_FACTOR, // D3 Forceê°€ ì´ ì´ˆê¸°ê°’ì„ ê¸°ì¤€ìœ¼ë¡œ ì‹œë®¬ë ˆì´ì…˜ ì‹œì‘
          y: d.y * INITIAL_COORDINATE_SCALE_FACTOR,
          z: d.z * INITIAL_COORDINATE_SCALE_FACTOR,
          url: `http://commbooks.com/ë„ì„œ-íƒœê·¸/${encodeURIComponent(d.id.replace(/\s+/g, '-'))}`,
          val: 0.5
        }));

        const graphData = { nodes, links: [] };
        let hoveredNode = null;

        const isMobile = /Mobi|Android/i.test(navigator.userAgent);

        const Graph = ForceGraph3D()
          (document.getElementById('graph-container'))
          .graphData(graphData)
          .nodeLabel(null)
          .nodeColor(node => pastelColors[node.group % pastelColors.length])
          .backgroundColor('#f5f0e6')
          .enableNodeDrag(false) // ë“œë˜ê·¸ëŠ” ì—¬ì „íˆ ë¹„í™œì„±í™”
          .nodeThreeObject(node => {
            const colorStr = pastelColors[node.group % pastelColors.length];
            const isHovered = hoveredNode === node; // í˜¸ë²„ ìƒíƒœì— ë”°ë¼ í…ìŠ¤ì²˜ ìƒì„±
            
            const material = new THREE.SpriteMaterial({
                map: getNodeTexture(node, colorStr, isHovered),
                transparent: true,
                depthWrite: false,
            });
            const sprite = new THREE.Sprite(material);

            const canvasForTexture = getNodeTexture(node, colorStr, isHovered).image;
            const spriteWidth = canvasForTexture.width;
            const spriteHeight = canvasForTexture.height;
            
            // â˜…â˜…â˜… ì›ë³¸ ì½”ë“œì˜ í˜¸ë²„ ìŠ¤ì¼€ì¼ë§ ë¡œì§ ìœ ì§€ â˜…â˜…â˜…
            let scale = NODE_BASE_SCALE * (isHovered ? HOVER_SCALE_FACTOR : 1);
            sprite.scale.set(spriteWidth * scale / 100, spriteHeight * scale / 100, 1);

            sprite.userData = { node, baseScaleX: sprite.scale.x, baseScaleY: sprite.scale.y };
            return sprite;
          })
          .onNodeHover(node => {
            const GFG = Graph;
            const container = document.getElementById('graph-container');
            if (hoveredNode === node && node !== null) return;
            
            // Update hovered node texture and scale (original behavior)
            if (hoveredNode) { // De-highlight previous
                const prevSprite = hoveredNode.__threeObj;
                if (prevSprite) {
                    const colorStr = pastelColors[hoveredNode.group % pastelColors.length];
                    if (prevSprite.material.map) prevSprite.material.map.dispose(); // ë©”ëª¨ë¦¬ í•´ì œ
                    prevSprite.material.map = getNodeTexture(hoveredNode, colorStr, false);
                    prevSprite.scale.set(prevSprite.userData.baseScaleX, prevSprite.userData.baseScaleY, 1);
                }
            }
            
            hoveredNode = node;

            if (node) {
                const currentSprite = node.__threeObj;
                if (currentSprite) {
                    const colorStr = pastelColors[node.group % pastelColors.length];
                    if (currentSprite.material.map) currentSprite.material.map.dispose(); // ë©”ëª¨ë¦¬ í•´ì œ
                    currentSprite.material.map = getNodeTexture(node, colorStr, true);
                    currentSprite.scale.set(
                        currentSprite.userData.baseScaleX * HOVER_SCALE_FACTOR, 
                        currentSprite.userData.baseScaleY * HOVER_SCALE_FACTOR, 
                        1
                    );
                }
                container.style.cursor = 'pointer';
                
                if (!isMobile) {
                  tooltipElement.style.display = 'block';
                  tooltipElement.innerHTML = node.name;
                } else {
                  tooltipElement.style.display = 'none';
                }

            } else {
                container.style.cursor = 'grab';
                tooltipElement.style.display = 'none';
            }
            GFG.renderer().domElement.addEventListener('mousemove', onMouseMoveTooltip, false);
          })
          .onNodeClick(node => {
            if (node.url) {
              window.open(node.url, '_blank');
            }
          })
          // â˜…â˜…â˜… D3 Force ì‹œë®¬ë ˆì´ì…˜ ì„¤ì • ì¶”ê°€ â˜…â˜…â˜…
          // ê¸°ë³¸ ì²™ë ¥ (charge) í˜ ì„¤ì •
          .d3Force('charge', d3.forceManyBody()
            .strength(-2) // ë…¸ë“œë“¤ì„ ì„œë¡œ ë°€ì–´ë‚´ëŠ” í˜ì˜ ê°•ë„. ìŒìˆ˜ì—¬ì•¼ ì²™ë ¥ì…ë‹ˆë‹¤. ì ˆëŒ€ê°’ì´ í´ìˆ˜ë¡ ê°•í•˜ê²Œ ë°€ì–´ëƒ…ë‹ˆë‹¤.
            .distanceMin(25) // ì´ ê±°ë¦¬(ì›”ë“œ ìœ ë‹›)ë³´ë‹¤ ê°€ê¹Œìš´ ë…¸ë“œë“¤ë§Œ ì²™ë ¥ì´ ì ìš©ë©ë‹ˆë‹¤.
                             // ì´ ê°’ì„ ì¡°ì ˆí•˜ì—¬ ê°€ê¹Œìš´ ë…¸ë“œë“¤ì´ í©ì–´ì§€ëŠ” ì •ë„ë¥¼ ì œì–´í•©ë‹ˆë‹¤.
                             // í˜„ì¬ NODE_BASE_SCALEì´ 15ì´ë‹ˆ 20ì •ë„ê°€ ì ì ˆí•œ ì‹œì‘ì ì…ë‹ˆë‹¤.
            .distanceMax(100) // ì´ ê±°ë¦¬ë³´ë‹¤ ë¨¼ ë…¸ë“œë“¤ ì‚¬ì´ì—ëŠ” ì²™ë ¥ì´ ì ìš©ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. (ì„ íƒì )
          )
          // ì‹œë®¬ë ˆì´ì…˜ ë©ˆì¶”ëŠ” ì†ë„ ì¡°ì ˆ
          .d3AlphaDecay(0.02) // 0.1ì€ ë„ˆë¬´ ë¹¨ë¼ì„œ ë…¸ë“œë“¤ì´ ì¶©ë¶„íˆ í©ì–´ì§€ì§€ ì•Šì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
                               // 0.02 ~ 0.05 ì‚¬ì´ì˜ ë‚®ì€ ê°’ìœ¼ë¡œ ì„¤ì •í•˜ì—¬ ì¶©ë¶„íˆ í©ì–´ì§€ë„ë¡ í•©ë‹ˆë‹¤.
          .d3VelocityDecay(0.5); 


        // ì¹´ë©”ë¼ ìœ„ì¹˜ ì„¤ì • (ì´ì „ê³¼ ë™ì¼)
        Graph.cameraPosition({ z: 250 });

        Graph.renderer().domElement.addEventListener('contextmenu', function(event) {
          event.preventDefault();
        }, false);
        const controls = Graph.controls();
        if (controls && controls.mouseButtons) {
          controls.mouseButtons.RIGHT = THREE.MOUSE.ROTATE;
          Graph.controls().enablePan = false;

          // âœ… ëª¨ë°”ì¼ì´ë©´ ë¹ ë¥´ê²Œ, ë°ìŠ¤í¬í†±ì´ë©´ ê¸°ë³¸
          controls.rotateSpeed = isMobile ? 0.85 : 0.5;
        }


        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        Graph.scene().add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
        directionalLight.position.set(1, 1, 1);
        Graph.scene().add(directionalLight);

        function onMouseMoveTooltip(event) {
            if (hoveredNode) {
                tooltipElement.style.left = (event.clientX + 10) + 'px';
                tooltipElement.style.top = (event.clientY + 10) + 'px';
            } else {
                tooltipElement.style.display = 'none';
            }
        }
        
        setTimeout(() => {
            const { nodes: graphNodes } = Graph.graphData();
            if (graphNodes.length) {
                let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity, minZ = Infinity, maxZ = -Infinity;
                graphNodes.forEach(n => {
                    // D3 Force ì‹œë®¬ë ˆì´ì…˜ì´ ëë‚œ í›„ì˜ ìµœì¢… ìœ„ì¹˜ (n.x, n.y, n.z)ë¥¼ ì‚¬ìš©
                    minX = Math.min(minX, n.x); maxX = Math.max(maxX, n.x);
                    minY = Math.min(minY, n.y); maxY = Math.max(maxY, n.y);
                    minZ = Math.min(minZ, n.z); maxZ = Math.max(maxZ, n.z);
                });

                const centerX = (minX + maxX) / 2;
                const centerY = (minY + maxY) / 2;
                const centerZ = (minZ + maxZ) / 2;
                const maxExtent = Math.max(maxX - minX, maxY - minY, maxZ - minZ);
                const camera = Graph.camera();
                if (camera) {
                    let camDistance = maxExtent / (2 * Math.tan(Math.PI * camera.fov / 360));
                    camDistance = Math.max(camDistance, 100);
                    camDistance = Math.min(camDistance, 2000);
                    Graph.cameraPosition(
                        { x: centerX, y: centerY, z: centerZ + camDistance * 1.2 },
                        { x: centerX, y: centerY, z: centerZ },
                        1000
                    );
                } else {
                     console.warn("ì¹´ë©”ë¼ ê°ì²´ë¥¼ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ì–´ ìë™ ìœ„ì¹˜ ì¡°ì •ì„ ìƒëµí•©ë‹ˆë‹¤.");
                     Graph.cameraPosition({ z: 400 + Math.max(maxX-minX, maxY-minY, maxZ-minZ) });
                }
            } else {
                Graph.cameraPosition({ x:0, y:0, z: 250 });
            }
        }, 1000);

        window.addEventListener('resize', () => {
            Graph.width(window.innerWidth);
            Graph.height(window.innerHeight);
        });

    }).catch(error => {
      console.error("ë°ì´í„° ë¡œë”© ë˜ëŠ” ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ:", error);
      const container = document.getElementById('graph-container');
      container.innerHTML = `<p style="color: red; text-align: center; padding-top: 50px;">ë°ì´í„° ë¡œë”© ì‹¤íŒ¨: ${error.message}</p>`;
    });

  </script>
</body>
</html>